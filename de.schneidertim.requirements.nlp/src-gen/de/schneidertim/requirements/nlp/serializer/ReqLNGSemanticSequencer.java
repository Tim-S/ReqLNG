/*
 * generated by Xtext 2.10.0
 */
package de.schneidertim.requirements.nlp.serializer;

import com.google.inject.Inject;
import de.schneidertim.requirements.nlp.reqLNG.Actor;
import de.schneidertim.requirements.nlp.reqLNG.ActorInteraction;
import de.schneidertim.requirements.nlp.reqLNG.ConceptCombination;
import de.schneidertim.requirements.nlp.reqLNG.ConceptOrSynonym;
import de.schneidertim.requirements.nlp.reqLNG.ConditionalRequirement;
import de.schneidertim.requirements.nlp.reqLNG.Description;
import de.schneidertim.requirements.nlp.reqLNG.DomainObject;
import de.schneidertim.requirements.nlp.reqLNG.Function;
import de.schneidertim.requirements.nlp.reqLNG.Glossary;
import de.schneidertim.requirements.nlp.reqLNG.Precondition;
import de.schneidertim.requirements.nlp.reqLNG.ReferenceCombination;
import de.schneidertim.requirements.nlp.reqLNG.ReqLNGPackage;
import de.schneidertim.requirements.nlp.reqLNG.RequirementDocument;
import de.schneidertim.requirements.nlp.reqLNG.RequirementEnd;
import de.schneidertim.requirements.nlp.reqLNG.SentenceWithReferences;
import de.schneidertim.requirements.nlp.reqLNG.TextWithConceptsOrSynonyms;
import de.schneidertim.requirements.nlp.reqLNG.TextWithReferences;
import de.schneidertim.requirements.nlp.reqLNG.UnconditionalRequirement;
import de.schneidertim.requirements.nlp.services.ReqLNGGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ReqLNGSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ReqLNGGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ReqLNGPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ReqLNGPackage.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case ReqLNGPackage.ACTOR_INTERACTION:
				sequence_ActorInteraction(context, (ActorInteraction) semanticObject); 
				return; 
			case ReqLNGPackage.CONCEPT_COMBINATION:
				sequence_ConceptCombination(context, (ConceptCombination) semanticObject); 
				return; 
			case ReqLNGPackage.CONCEPT_OR_SYNONYM:
				if (rule == grammarAccess.getDomainObjectSynonymRule()) {
					sequence_DomainObjectSynonym(context, (ConceptOrSynonym) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFunctionSynonymRule()) {
					sequence_FunctionSynonym(context, (ConceptOrSynonym) semanticObject); 
					return; 
				}
				else break;
			case ReqLNGPackage.CONDITIONAL_REQUIREMENT:
				sequence_ConditionalRequirement(context, (ConditionalRequirement) semanticObject); 
				return; 
			case ReqLNGPackage.DESCRIPTION:
				sequence_Description(context, (Description) semanticObject); 
				return; 
			case ReqLNGPackage.DOMAIN_OBJECT:
				sequence_DomainObject(context, (DomainObject) semanticObject); 
				return; 
			case ReqLNGPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case ReqLNGPackage.GLOSSARY:
				sequence_Glossary(context, (Glossary) semanticObject); 
				return; 
			case ReqLNGPackage.PRECONDITION:
				sequence_Precondition(context, (Precondition) semanticObject); 
				return; 
			case ReqLNGPackage.REFERENCE_COMBINATION:
				sequence_ReferenceCombination(context, (ReferenceCombination) semanticObject); 
				return; 
			case ReqLNGPackage.REQUIREMENT_DOCUMENT:
				sequence_RequirementDocument(context, (RequirementDocument) semanticObject); 
				return; 
			case ReqLNGPackage.REQUIREMENT_END:
				sequence_RequirementEnd(context, (RequirementEnd) semanticObject); 
				return; 
			case ReqLNGPackage.SENTENCE_WITH_REFERENCES:
				sequence_SentenceWithReferences(context, (SentenceWithReferences) semanticObject); 
				return; 
			case ReqLNGPackage.SYSTEM:
				sequence_System(context, (de.schneidertim.requirements.nlp.reqLNG.System) semanticObject); 
				return; 
			case ReqLNGPackage.TEXT_WITH_CONCEPTS_OR_SYNONYMS:
				sequence_TextWithConceptsOrSynonyms(context, (TextWithConceptsOrSynonyms) semanticObject); 
				return; 
			case ReqLNGPackage.TEXT_WITH_REFERENCES:
				sequence_TextWithReferences(context, (TextWithReferences) semanticObject); 
				return; 
			case ReqLNGPackage.UNCONDITIONAL_REQUIREMENT:
				sequence_UnconditionalRequirement(context, (UnconditionalRequirement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ActorInteraction returns ActorInteraction
	 *
	 * Constraint:
	 *     (
	 *         provide='provide' 
	 *         the1='the'? 
	 *         actor=[Actor|STRING] 
	 *         with='with' 
	 *         the2='the' 
	 *         ability='ability' 
	 *         to='to'
	 *     )
	 */
	protected void sequence_ActorInteraction(ISerializationContext context, ActorInteraction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Actor
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (name=Text description=Description)
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.ENTITY__NAME));
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.ENTITY__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.ENTITY__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActorAccess().getNameTextParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getActorAccess().getDescriptionDescriptionParserRuleCall_3_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConceptCombination returns ConceptCombination
	 *
	 * Constraint:
	 *     (concepts+=[ConceptOrSynonym|STRING]+ text+=Text)
	 */
	protected void sequence_ConceptCombination(ISerializationContext context, ConceptCombination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns ConditionalRequirement
	 *     ConditionalRequirement returns ConditionalRequirement
	 *
	 * Constraint:
	 *     (condition=Precondition? system=[System|STRING] liability=Liability end=RequirementEnd)
	 */
	protected void sequence_ConditionalRequirement(ISerializationContext context, ConditionalRequirement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Description returns Description
	 *
	 * Constraint:
	 *     text+=SentenceWithReferences+
	 */
	protected void sequence_Description(ISerializationContext context, Description semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DomainObjectSynonym returns ConceptOrSynonym
	 *
	 * Constraint:
	 *     name=Text
	 */
	protected void sequence_DomainObjectSynonym(ISerializationContext context, ConceptOrSynonym semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.CONCEPT_OR_SYNONYM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.CONCEPT_OR_SYNONYM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDomainObjectSynonymAccess().getNameTextParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns DomainObject
	 *     DomainObject returns DomainObject
	 *
	 * Constraint:
	 *     (name=Text (synonyms+=DomainObjectSynonym synonyms+=DomainObjectSynonym*)? description+=SentenceWithReferences*)
	 */
	protected void sequence_DomainObject(ISerializationContext context, DomainObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionSynonym returns ConceptOrSynonym
	 *
	 * Constraint:
	 *     name=Text
	 */
	protected void sequence_FunctionSynonym(ISerializationContext context, ConceptOrSynonym semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.CONCEPT_OR_SYNONYM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.CONCEPT_OR_SYNONYM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionSynonymAccess().getNameTextParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=Text (synonyms+=FunctionSynonym synonyms+=FunctionSynonym*)? description+=SentenceWithReferences*)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Glossary returns Glossary
	 *
	 * Constraint:
	 *     concepts+=Concept*
	 */
	protected void sequence_Glossary(ISerializationContext context, Glossary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Precondition returns Precondition
	 *
	 * Constraint:
	 *     (conditional=Conditional condition=TextWithReferences)
	 */
	protected void sequence_Precondition(ISerializationContext context, Precondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.PRECONDITION__CONDITIONAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.PRECONDITION__CONDITIONAL));
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.PRECONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.PRECONDITION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreconditionAccess().getConditionalConditionalParserRuleCall_0_0(), semanticObject.getConditional());
		feeder.accept(grammarAccess.getPreconditionAccess().getConditionTextWithReferencesParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ReferenceCombination returns ReferenceCombination
	 *
	 * Constraint:
	 *     (refs+=[Entity|STRING]+ text+=Text)
	 */
	protected void sequence_ReferenceCombination(ISerializationContext context, ReferenceCombination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementDocument returns RequirementDocument
	 *
	 * Constraint:
	 *     ((entities+=Entity | requirement+=Requirement)* glossary=Glossary)
	 */
	protected void sequence_RequirementDocument(ISerializationContext context, RequirementDocument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RequirementEnd returns RequirementEnd
	 *
	 * Constraint:
	 *     (ai=ActorInteraction? objectWithDetails=TextWithConceptsOrSynonyms)
	 */
	protected void sequence_RequirementEnd(ISerializationContext context, RequirementEnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SentenceWithReferences returns SentenceWithReferences
	 *
	 * Constraint:
	 *     (textWithReferences=TextWithReferences (punctuation='.' | punctuation='!' | punctuation='?'))
	 */
	protected void sequence_SentenceWithReferences(ISerializationContext context, SentenceWithReferences semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns System
	 *     System returns System
	 *
	 * Constraint:
	 *     (name=Text description=Description)
	 */
	protected void sequence_System(ISerializationContext context, de.schneidertim.requirements.nlp.reqLNG.System semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.ENTITY__NAME));
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.ENTITY__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.ENTITY__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSystemAccess().getNameTextParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSystemAccess().getDescriptionDescriptionParserRuleCall_3_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TextWithConceptsOrSynonyms returns TextWithConceptsOrSynonyms
	 *
	 * Constraint:
	 *     (
	 *         onlyRefs+=[ConceptOrSynonym|STRING]+ | 
	 *         (refBefore+=[ConceptOrSynonym|STRING]* text+=Text after+=ConceptCombination* finalRef+=[ConceptOrSynonym|STRING]*)
	 *     )
	 */
	protected void sequence_TextWithConceptsOrSynonyms(ISerializationContext context, TextWithConceptsOrSynonyms semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TextWithReferences returns TextWithReferences
	 *
	 * Constraint:
	 *     (onlyRefs+=[Entity|STRING]+ | (refBefore+=[Entity|STRING]* text+=Text after+=ReferenceCombination* finalRef+=[Entity|STRING]*))
	 */
	protected void sequence_TextWithReferences(ISerializationContext context, TextWithReferences semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns UnconditionalRequirement
	 *     UnconditionalRequirement returns UnconditionalRequirement
	 *
	 * Constraint:
	 *     (the='The' system=[System|STRING] liability=Liability end=RequirementEnd)
	 */
	protected void sequence_UnconditionalRequirement(ISerializationContext context, UnconditionalRequirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.UNCONDITIONAL_REQUIREMENT__THE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.UNCONDITIONAL_REQUIREMENT__THE));
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.REQUIREMENT__SYSTEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.REQUIREMENT__SYSTEM));
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.REQUIREMENT__LIABILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.REQUIREMENT__LIABILITY));
			if (transientValues.isValueTransient(semanticObject, ReqLNGPackage.Literals.REQUIREMENT__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReqLNGPackage.Literals.REQUIREMENT__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnconditionalRequirementAccess().getTheTheKeyword_0_0(), semanticObject.getThe());
		feeder.accept(grammarAccess.getUnconditionalRequirementAccess().getSystemSystemSTRINGTerminalRuleCall_1_0_1(), semanticObject.getSystem());
		feeder.accept(grammarAccess.getUnconditionalRequirementAccess().getLiabilityLiabilityEnumRuleCall_2_0(), semanticObject.getLiability());
		feeder.accept(grammarAccess.getUnconditionalRequirementAccess().getEndRequirementEndParserRuleCall_3_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
}
